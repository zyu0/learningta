# 简单顶点/片元着色器

## 基本结构

Shader，Property，SubShader（内含Pass），Fallback等语义块组成

## 最简单

Unity版本 2017.1.0f3 Personal(64bit)

```c++
// Upgrade NOTE: replaced 'mul(UNITY_MATRIX_MVP,*)' with 'UnityObjectToClipPos(*)'

Shader "Unity Shader Book/Chapter 5/Simple Shader" {
	SubShader {
		Pass {
			CGPROGRAM

			#pragma vertex vert
			#pragma fragment frag

			float4 vert(float4 v : POSITION) : SV_POSITION {
				return UnityObjectToClipPos(v);
			}

			fixed4 frag() : SV_Target {
				return fixed4(1.0, 1.0, 1.0, 1.0);
			}

			ENDCG
		}
	}
}

```

**错误注意点：****

- Shader名称写明路径，便于快速查找
- `#pragma `中间没有空格，这里#表示的是编译指令，告诉Unity函数作用
- SV_POSITION不要写成SC_POSITION
- fixed4 frag() : 别丢了4
- `return fixed4(1.0, 1.0, 1.0, 1.0);`，别丢了 ； 

**语法注意点：**

- ==POSITION、SV_POSITION，SV_Target是Unity语义，限定输入和输出参数==

- ` float4 v : POSITION`，v是函数输入的顶点数据，float4是返回值，表示顶点在裁剪空间中的位置
- `float4 vert(float4 v : POSITION) : SV_POSITION`，`fixed4 frag() : SV_Target`中最前面的float4和fixed4都是定义的属性类型



此处**POSITION**表明告诉Unity，把模型顶点坐标填充到输入参数 v 中，**SV_POSITION**告诉Unity，顶点着色器的输出是裁剪空间中的顶点坐标；**SV_Target**告诉渲染器把用户的输出颜色存储到一个渲染目标（render target）



片元着色器输出颜色每个分量范围在[0,1]，（0,0,0）黑色，（1,1,1）白色

## 修改一

得到模型每个顶点的纹理坐标和法线方向

```c++
Shader "Unity Shader Book/Chapter 5/Simple Shader2" {
	SubShader {
		Pass {
			CGPROGRAM

			#pragma vertex vert
			#pragma fragment frag
			// 使用一个结构体来定义顶点着色器的输入
            // a(application),2(to),v(vertex shader) 
			struct a2v {
				// POSITION 语义告诉Unity，用模型空间的顶点坐标填充vertex变量
				float4 vertex : POSITION;
				// NORMAL 语义告诉Unity，用模型的法线方向填充normal变量
				float3 normal : NORMAL;
				// TEXCOORD0 语义告诉Unity，用模型第一套纹理坐标填充texcoord变量
				float4 texcoord : TEXCOORD0;
			};

			float4 vert(float4 v : POSITION) : SV_POSITION {
				return UnityObjectToClipPos(v);
			}

			fixed4 frag() : SV_Target {
				return fixed4(1.0, 1.0, 1.0, 1.0);
			}

			ENDCG
		}
	}
}
```

注意点：别忘了结构体{}后面的 ；

通过POSITION，NORMAL，TEXCOORD0这些语义，Unity会填充这个结构体

> 对于顶点着色器的输入，Unity支持语义：
>
> - POSITION
> - TANGENT
> - NORMAL
> - TEXCOORD0
> - TEXCOORD1
> - TEXCOORD2
> - TEXCOORD3
> - COLOR

定义结构体格式：

```c
struct StructNmae {
	Type Name : Semantic;
    Type Name : Semantic;
    ...
}
```

填充到POSITION，NORMAL，TEXCOORD0等语义块中的数据来自Unity的材质Mesh Render组件。每帧调用Draw Call时，Mesh Render组件会把其负责渲染的模型数据发送给Unity Shader



## 修改二

顶点着色器与片元着色器通信，从顶点着色器输出数据到片元

```c
Shader "Unity Shader Book/Chapter 5/Simple Shader" {
	SubShader {
		Pass {
			CGPROGRAM

			#pragma vertex vert
			#pragma fragment frag

			// 使用一个结构体来定义顶点着色器的输入
			struct a2v {
				// POSITION 语义告诉Unity，用模型空间的顶点坐标填充vertex变量
				float4 vertex : POSITION;
				// NORMAL 语义告诉Unity，用模型的法线方向填充normal变量
				float3 normal : NORMAL;
				// TEXCOORD0 语义告诉Unity，用模型第一套纹理坐标填充texcoord变量
				float4 texcoord : TEXCOORD0;
			};

			//使用一个结构体来定义顶点着色器的输出
			struct v2f {
				// SV_POSITION 语义告诉Unity，pos里包含了顶点在裁剪空间中的位置信息
				float4 pos : SV_POSITION;
				// COLOR 语义可以用于存储颜色信息
				fixed3 color : COLOR0;
			};
		//  输出 入口函数 输入
			v2f vert(a2v v) {
				// 声明输出结构
				v2f o;
                // 使用v.vertex访问模型空间的顶点坐标
				o.pos = UnityObjectToClipPos(v.vertex);  
				// v.normal包含了顶点的法线方向，其分量在[-1.0, 1.0]
				// 下面的代码把分量范围映射到[0.0， 1.0]
				// 存储到o.color中传递给片元着色器，法线是向量，是三个数据
				o.color = v.normal * 0.5 + fixed3(0.5, 0.5, 0.5);
				return o;
			}
			// v2f在此处作为输入
			fixed4 frag(v2f i) : SV_Target {
				// 将插值后的i.color显示到屏幕上
				return fixed4(i.color, 1.0);
			}

			ENDCG
		}
	}
}

```

注意点：

顶点着色器是逐顶点调用的，片元着色器是逐片元调用，片元着色器的输入实际是把顶点着色器的输出进行插值后的结果。（应是光栅化阶段的三角形遍历）

## 修改三

材质和Unity Shader的关系，增加方便调节Unity Shader参数的方式，这些参数写在Property语义块中

```c
// Upgrade NOTE: replaced 'mul(UNITY_MATRIX_MVP,*)' with 'UnityObjectToClipPos(*)'

Shader "Unity Shader Book/Chapter 5/Simple Shader2" {
	Properties {
		// 声明一个Color类型的属性
		_Color ("Color Tint", Color) = (1.0, 1.0, 1.0, 1.0)
	}
	
	SubShader {
		Pass {
			CGPROGRAM

			#pragma vertex vert
			#pragma fragment frag

			fixed4 _Color;

			// 使用一个结构体来定义顶点着色器的输入
			struct a2v {
				float4 vertex : POSITION;
				float3 normal : NORMAL;
				float4 texcoord : TEXCOORD0;
			};

			//使用一个结构体来定义顶点着色器的输出
			struct v2f {
				float4 pos : SV_POSITION;
				fixed3 color : COLOR0;
			};

			v2f vert(a2v v) {
				v2f o;
				o.pos = UnityObjectToClipPos(v.vertex); 
				o.color = v.normal * 0.5 + fixed3(0.5, 0.5, 0.5);
				return o;
			}

			fixed4 frag(v2f i) : SV_Target {
				fixed3 c = i.color;
				c *= _Color.rgb;
				return fixed4(c, 1.0);  # 此处还不是很明确
			}

			ENDCG
		}
	}
}

```

错误注意点：

​				float4 vertex : POSITION;
​				float3 normal : NORMAL;
​				float4 texcoord : TEXCOORD0;

此处的变量类型要注意是几维的

![image-20201110154712111](assets/image-20201110154712111.png)



struct 很像是python中的 class，内部定义的`float4 pos：SV_POSITION`就类似类方法，外部可以调用类方法`o.pos`





## 对语义的注意

语义是赋给Shader输入和输出的字符串，字符串标注了参数的含义、

语义即使同名，出现的位置不同，含义不同

DirectX 10 后出现的 系统数值语义（system-value semantics），SV开头

`float4 pos : SV_POSITION;`，SV_POSITION是对变量pos的修饰，使pos具有了特定的含义（包含可用于光栅化的变换后的顶点坐标），这种被语义修饰的变量是不可以被随意赋值的，有特定功能。

![image-20201110154645487](assets/image-20201110154645487.png)

其中TEXCOORDn 中n 的数目是和Shader Model有关的，例如一般在Shader Model2（即Unity默认编译到的Shader Model版本）和Shader Model3中，n等于8，而在Shader Model4和Shader Model5中，n等于16。通常情况下，一个模型的纹理坐标组数一般不超过2，即我们往往只使用TEXCOORD0和TEXCOORD1。

==在Unity内置的数据结构体appdata_full中，它最多使用了6个坐标纹理组。==

==一个语义可以使用的寄存器只能处理4个浮点值（float)。==float4×4等变量就需要使用更多的空间。一种方法是，把这些变量==拆分==成多个变量，例如对于float4×4的矩阵类型，我们可以拆分成4个float4类型的变量，每个变量存储了矩阵中的一行数据。













